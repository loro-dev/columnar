use std::{borrow::Cow, collections::BTreeMap, marker::PhantomData};

use serde_columnar::{
    columnar, from_bytes, iter_from_bytes,
    iterable::{AnyRleIter, DeltaRleIter, GenericIter},
    to_vec,
};

#[columnar(vec, map, ser, de, iterable)]
#[derive(Debug, Clone)]
pub struct Data<'a> {
    #[columnar(strategy = "DeltaRle")]
    a: u32,
    #[columnar(strategy = "Rle")]
    b: String,
    l: PhantomData<&'a ()>,
}

#[columnar(ser, de)]
#[derive(Debug)]
struct VecStore<'a> {
    #[columnar(class = "vec", iter = "Data<'a>")]
    data: Vec<Data<'a>>,
    id: u32,
}

//================= will be generated by macro

// #[columnar(de)]
// pub struct VecStoreIter<'a> {
//     pub data: IterableData<'a>,
//     pub id: u32,
// }

// impl<'de: 'a, 'a> TableIter<'de> for VecStore<'a> {
//     type Iter = VecStoreIter<'de, 'a>;
// }

// #[columnar(de)]
// pub struct IterableData<'i, 'a> {
//     a: DeltaRleIter<'i, u32>,
//     b: AnyRleIter<'i, String>,
//     l: GenericsIter<'i, PhantomData<&'a ()>>,
// }

// impl<'de, 'a> Iterator for IterableData<'de, 'a> {
//     type Item = Data<'a>;
//     fn next(&mut self) -> Option<Self::Item> {
//         let next_a = self.a.next();
//         let next_b = self.b.next();
//         let next_l = self.l.next();
//         if let (Some(a), Some(b), Some(l)) = (next_a, next_b, next_l) {
//             Some(Data { a, b, l })
//         } else {
//             None
//         }
//     }
// }

#[columnar(vec, map, ser, de, iterable)]
#[derive(Debug, Clone, Default)]
pub struct ComplexData<'a> {
    #[columnar(strategy = "Rle")]
    rle: u8,
    #[columnar(strategy = "DeltaRle")]
    delta_rle_uint: u64,
    #[columnar(strategy = "BoolRle")]
    bool_rle: bool,
    #[columnar(strategy = "Rle")]
    tuple_rle: (u16, String),
    #[columnar(borrow)]
    borrow_str: Cow<'a, str>,
    #[columnar(skip)]
    skip: bool,
    #[columnar(class = "vec", iter = "Data<'a>")]
    vec: Vec<ComplexData<'a>>,
    #[columnar(class = "map")]
    map: BTreeMap<String, Data<'a>>,
    #[columnar(optional, index = 0)]
    optional: u32,
    #[columnar(borrow, optional, index = 1)]
    borrow_optional_bytes: Cow<'a, str>,
}

fn main() {
    let data = vec![
        Data {
            a: 100,
            b: "a".to_string(),
            l: Default::default(),
        },
        Data {
            a: 101,
            b: "a".to_string(),
            l: Default::default(),
        },
        Data {
            a: 102,
            b: "a".to_string(),
            l: Default::default(),
        },
    ];
    let store = VecStore { data, id: 7 };

    let bytes = to_vec(&store).unwrap();

    println!("encode bytes {:?}", bytes);
    let store: VecStore = from_bytes(&bytes).unwrap();
    println!("store {:?}", store);
    let iter_store = iter_from_bytes::<VecStore>(&bytes).unwrap();
    // println!("data len {}", iter_store.data.count());
    for data in iter_store.data {
        println!("# {:?}", data)
    }
    assert_eq!(iter_store.id, 7)
}
